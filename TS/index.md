## Typescript

## pros
Typescript has various features which optimize JS code that gradually get introduced to the main JS langiage over time.
It adds an extra layer of type protection with the aim to minimise bugs introduced by the loosely typed language.
Typescipt is a superset of JS which means it has all the features which JS has.

### cons
We need a compiler to transpile typescript so browsers understand it
Writting TS takes more time to learn and write.

## Setup
We should install typescipt on out machine globally so it can be accessed anywhere:
`sudo npm i -g typescript`
We can verify the install by checking the version like so: `tsc -v`

Compiling TS is done by running `tsc <TYPESCRIPT_FILE>`
The TS compiler uses ecmascript 2015 which has full browser supper.

### [Configure TS compiler](https://www.youtube.com/watch?v=d56mG7DezGs&t=11s)
We can modify the TS compiler for contemporary JS version.
We need to create a `tsconfig.json` file which is generated by running `tsc --init`.
After uncommenting and modifying the `root-dir`, `output-dir` and other settings, we can run `tsc` where the config resides and it will compile the code.

### [Debugging in VS Code](https://www.youtube.com/watch?v=d56mG7DezGs&t=11s)
VS code has an integrated debugging tool which allows us to add breakpoints and watchers. Very usefule when inspecting code for issues.

## TS Types
![has_one_&_has_many](https://github.com/MarkCondello/dev-notes/blob/main/TS/imgs/types.png)

With TS code, types like above are inferred based on the initialised value:
```
let sales: number = 123_456_789,
course = 'Typescript', // inferred string type
is_published: boolean = true
```
We should avoid using the `any` type as much as possible as it goes against the whole benefit of using TS.

### Arrays
We can infer what type an array is like so:
`let number: string[] = [1,2,'3'];`
TS will complain the the number values are invalid types.
Becuase the editor know the type it expects, the editor will infer methods available to it with intellisence code completion which JS does not do.

#### Tuples
Tuples are the combination of various types for a array. See an example below:
```let user: [number, string] = [1, 'Markamus']```
It is best to keep tuples to 2 values otherwise the code gets hard to read. Things like key value pairs are best.

#### Enum
Enums are a set of related values which can be referenced by a key.
By convention enums have an uppercase first letter
``` enum Size { Small = 1, Medium, Large } ```
If we add string values, then each value needs to be added explicitly.
By adding a `const` to an enum, the compiled generates more easier to read code.

### Functions
As a best practice, functions should always have an explicit return type.
Params should have their types set or default values added.
The following configurations shoule be enabled for more typeproof functions:
```
    "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
```

Below is function demo which implements these best practices:
```
function calcTax(income: number, taxYear = 2022): number {
  if (taxYear < 2022) {
    return income * 1.2
  }
   return income * 1.3;
}
calcTax(10_000, 2023);
```

### Objects
We can determine which properties mush be added to an object. See example below:
```
let employee: {
  id: number,
  name: string
} = { id: 1, name: 'Mark' }

employee.id = 'something'//invalid
employee.name = 1234//invalid
```

TS also provide a `readonly` property for object items:
```
let employee: {
  readonly id: number,
  name: string
} = { id: 1, name: 'Mark' }

employee.id = 123 //invalid
```
Defining methods on an object is checked by defining the returned value and the functions params:
```
let employee: {
  ...
  retire: (date: Date) => void
} = {
  ...
  retire: (date: Date) => {
    console.log(date)
  } 
}
```
This approach is verbose and there is a better way to set custom object shapes with a Type Alias.

### Type Alias
```
type Employee = {
  id: number,
  name: string,
  retire: (date: Date) => void
}
let dateObj = new Date();
let goon: Employee = {
  id: 4321,
  name: 'Lacky',
  retire(dateObj) {
    return dateObj.setFullYear(dateObj.getFullYear() + 10)
  }
}
```

### Union Types
In the below example we dont know what type the weight param will be. This is where we can use Narrowing to determine what type the param is. TS will will still provide us with the inferred intellisence after the Narrowing is performed.

```
function kgToLbs(weight: number | string) : number {
  if (typeof weight === 'number') {
    return weight * 2.2
  } else {
    return parseInt(weight) * 2.2
  }
}

let tenKgToPndNumber = kgToLbs(10)
let tenKgToPndString = kgToLbs('10kgs')
```

### Intersection Types
An object which is a number and a string at a same time.